# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all
# figurate (polygonal) numbers and are generated by the following formulae:
# Triangle 	  	    P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
# Square 	  	    P4,n=n2 	  	    1, 4, 9, 16, 25, ...
# Pentagonal 	  	P5,n=n(3n-1)/2 	  	1, 5, 12, 22, 35, ...
# Hexagonal 	  	P6,n=n(2n-1) 	  	1, 6, 15, 28, 45, ...
# Heptagonal 	  	P7,n=n(5n-3)/2 	  	1, 7, 18, 34, 55, ...
# Octagonal 	  	P8,n=n(3n-2) 	  	1, 8, 21, 40, 65, ...
#
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
#
#     The set is cyclic, in that the last two digits of each number is the first two digits of the
#     next number (including the last number with the first).
#     Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882),
#     is represented by a different number in the set.
#     This is the only set of 4-digit numbers with this property.
#
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal
# type triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a
# different number in the set.


# First, we need to implement each figurate method.

def triangular(n):
    return (n * (n + 1)) / 2

def square(n):
    return (n * n)

def pentagonal(n):
    return (n * ((3 * n) - 1)) / 2

def hexagonal(n):
    return n * ((2 * n) - 1)

def heptagonal(n):
    return (n * ((5 * n) - 3) / 2)

def octagonal(n):
    return (n * ((3 * n) - 2))

# Next, we need to generate lists of all 4-digit figurate numbers by type.

def generate_list(method):
    nums = []
    last = 0
    while len(str(last)) < 5:
        for i in range(1, 1000):
            last = method(i)
            if len(str(last)) == 4:
                nums.append(last)
    return nums

triangles = generate_list(triangular)
squares = generate_list(square)
pentagons = generate_list(pentagonal)
hexagons = generate_list(hexagonal)
heptagons = generate_list(heptagonal)
octagons = generate_list(octagonal)

# We need a way to compare two given lists.

def compare_lists(first_list, list_to_compare):
    matches = []
    for number in first_list:
        last_two = str(number)[-2:]
        for item in list_to_compare:
            first_two = str(item)[:2]
            if last_two == first_two:
                matches.append([number, item])
    return matches

def last_item_of(some_list):
    return some_list[-1]

def first_item_of(some_list):
    return some_list[0]

def eliminate_candidates(candidate_list, next_list):
    highest_candidates = []
    new_candidates = []
    for candidate in candidate_list:
        highest_candidates.append(last_item_of(candidate))
    new_matches = compare_lists(highest_candidates, next_list)
    for candidate in candidate_list:
        print "TESTING", candidate
        for match in new_matches:
            print "MATCHING", match
            if last_item_of(candidate) == first_item_of(match):
                new_can = candidate[:]
                new_can.append(last_item_of(match))
                if new_can not in(new_candidates):
                    new_candidates.append(new_can)
                    print "========================found"
                    print "==========================", new_can
    return new_candidates