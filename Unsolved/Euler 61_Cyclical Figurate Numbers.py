# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all
# figurate (polygonal) numbers and are generated by the following formulae:
# Triangle 	  	    P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
# Square 	  	    P4,n=n2 	  	    1, 4, 9, 16, 25, ...
# Pentagonal 	  	P5,n=n(3n-1)/2 	  	1, 5, 12, 22, 35, ...
# Hexagonal 	  	P6,n=n(2n-1) 	  	1, 6, 15, 28, 45, ...
# Heptagonal 	  	P7,n=n(5n-3)/2 	  	1, 7, 18, 34, 55, ...
# Octagonal 	  	P8,n=n(3n-2) 	  	1, 8, 21, 40, 65, ...
#
# The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
#
#     The set is cyclic, in that the last two digits of each number is the first two digits of the
#     next number (including the last number with the first).
#     Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882),
#     is represented by a different number in the set.
#     This is the only set of 4-digit numbers with this property.
#
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal
# type triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a
# different number in the set.


# First, we need to implement each figurate method.

def triangular(n):
    return (n * (n + 1)) / 2

def square(n):
    return (n * n)

def pentagonal(n):
    return (n * ((3 * n) - 1)) / 2

def hexagonal(n):
    return n * ((2 * n) - 1)

def heptagonal(n):
    return (n * ((5 * n) - 3) / 2)

def octagonal(n):
    return (n * ((3 * n) - 2))

# Next, we need to generate lists of all 4-digit figurate numbers by type.

def generate_list(method):
    nums = []
    last = 0
    while len(str(last)) < 5:
        for i in range(1, 1000):
            last = method(i)
            if len(str(last)) == 4:
                nums.append(last)
    return nums

triangles = generate_list(triangular)
squares = generate_list(square)
pentagons = generate_list(pentagonal)
hexagons = generate_list(hexagonal)
heptagons = generate_list(heptagonal)
octagons = generate_list(octagonal)

# Let's add a 'type' to each entry based on the figurate value.

def add_type(type_value, list_to_type):
    for i in list_to_type:
        ind = list_to_type.index(i)
        list_to_type[ind] = (type_value, i)

add_type(3, triangles)
add_type(4, squares)
add_type(5, pentagons)
add_type(6, hexagons)
add_type(7, heptagons)
add_type(8, octagons)

# Combine all these in a list:

all_figurate_numbers = triangles + squares + pentagons + hexagons + heptagons + octagons

# Time to build a dict of all entries, and the numbers that COULD follow them...

families = {}

for item in all_figurate_numbers:
    dict_entry = []
    last_two = str(item[1])
    last_two = last_two[-2:]
    for other_item in all_figurate_numbers:
        first_two = str(other_item[1])
        first_two = first_two[:2]
        if last_two == first_two:
            dict_entry.append(other_item)
    families.update({item : dict_entry})

six_member_families = {}

for family in families:
    entry = len(families[family])
    if entry == 6:
        six_member_families.update({family : families[family]})

reference_list = [3, 4, 5, 6, 7, 8]
reference_set = set()
for i in reference_list:
    reference_set.add(i)

narrow_candidates = {}
for key in six_member_families:
    this_set = set()
    val = six_member_families[key]
    for tup in val:
        p_type = tup[0]
        this_set.add(p_type)
        if this_set == reference_set:
            narrow_candidates.update({key : val})

for key in narrow_candidates:
    print key, "=", narrow_candidates[key]

# WRONG





